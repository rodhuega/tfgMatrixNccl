# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_NvRules')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_NvRules')
    _NvRules = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_NvRules', [dirname(__file__)])
        except ImportError:
            import _NvRules
            return _NvRules
        if fp is not None:
            try:
                _mod = imp.load_module('_NvRules', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _NvRules = swig_import_helper()
    del swig_import_helper
else:
    import _NvRules
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


def require_metrics(handle, metrics):
    ev = get_evaluator(handle)
    for metric in metrics:
        ev.require_metric(metric)

def require_rules(handle, rules):
    ev = get_evaluator(handle)
    for rule in rules:
        ev.require_rule(rule)

def metric_instances(metric):
    instances = []

    for idx in range(metric.num_instances()):
        kind = metric.kind(idx)
        if (kind == IMetric.ValueKind_FLOAT) or (kind == IMetric.ValueKind_DOUBLE):
            instances.append(metric.as_double(idx))
        elif (kind == IMetric.ValueKind_UINT64) or (kind == IMetric.ValueKind_UINT32):
            instances.append(metric.as_uint64(idx))
        else:
            instances.append(metric.as_string(idx))

    return instances

RuleKind_DEFAULT = _NvRules.RuleKind_DEFAULT
RuleKind_GUIDED = _NvRules.RuleKind_GUIDED
class IMetric(_object):
    """Proxy of C++ NV::Rules::IMetric class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IMetric, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IMetric, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ValueKind_UNKNOWN = _NvRules.IMetric_ValueKind_UNKNOWN
    ValueKind_ANY = _NvRules.IMetric_ValueKind_ANY
    ValueKind_STRING = _NvRules.IMetric_ValueKind_STRING
    ValueKind_FLOAT = _NvRules.IMetric_ValueKind_FLOAT
    ValueKind_DOUBLE = _NvRules.IMetric_ValueKind_DOUBLE
    ValueKind_UINT32 = _NvRules.IMetric_ValueKind_UINT32
    ValueKind_UINT64 = _NvRules.IMetric_ValueKind_UINT64
    __swig_destroy__ = _NvRules.delete_IMetric
    __del__ = lambda self: None

    def name(self):
        """
        name(IMetric self) -> char const *

        Parameters
        ----------
        self: NV::Rules::IMetric *

        """
        return _NvRules.IMetric_name(self)


    def kind(self, *args):
        """
        kind(IMetric self) -> NV::Rules::IMetric::ValueKind
        kind(IMetric self, size_t instance) -> NV::Rules::IMetric::ValueKind

        Parameters
        ----------
        instance: size_t

        """
        return _NvRules.IMetric_kind(self, *args)


    def has_value(self, value_kind):
        """
        has_value(IMetric self, NV::Rules::IMetric::ValueKind value_kind) -> bool

        Parameters
        ----------
        value_kind: enum NV::Rules::IMetric::ValueKind

        """
        return _NvRules.IMetric_has_value(self, value_kind)


    def as_double(self, *args):
        """
        as_double(IMetric self) -> double
        as_double(IMetric self, size_t instance) -> double

        Parameters
        ----------
        instance: size_t

        """
        return _NvRules.IMetric_as_double(self, *args)


    def as_uint64(self, *args):
        """
        as_uint64(IMetric self) -> uint64_t
        as_uint64(IMetric self, size_t instance) -> uint64_t

        Parameters
        ----------
        instance: size_t

        """
        return _NvRules.IMetric_as_uint64(self, *args)


    def as_string(self, *args):
        """
        as_string(IMetric self) -> char const
        as_string(IMetric self, size_t instance) -> char const *

        Parameters
        ----------
        instance: size_t

        """
        return _NvRules.IMetric_as_string(self, *args)


    def num_instances(self):
        """
        num_instances(IMetric self) -> size_t

        Parameters
        ----------
        self: NV::Rules::IMetric *

        """
        return _NvRules.IMetric_num_instances(self)


    def has_correlation_ids(self):
        """
        has_correlation_ids(IMetric self) -> bool

        Parameters
        ----------
        self: NV::Rules::IMetric *

        """
        return _NvRules.IMetric_has_correlation_ids(self)


    def correlation_ids(self):
        """
        correlation_ids(IMetric self) -> IMetric

        Parameters
        ----------
        self: NV::Rules::IMetric *

        """
        return _NvRules.IMetric_correlation_ids(self)

IMetric_swigregister = _NvRules.IMetric_swigregister
IMetric_swigregister(IMetric)

class IAction(_object):
    """Proxy of C++ NV::Rules::IAction class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IAction, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IAction, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IAction
    __del__ = lambda self: None

    def name(self):
        """
        name(IAction self) -> char const *

        Parameters
        ----------
        self: NV::Rules::IAction *

        """
        return _NvRules.IAction_name(self)


    def metric_by_name(self, metric_name):
        """
        metric_by_name(IAction self, char const * metric_name) -> IMetric

        Parameters
        ----------
        metric_name: char const *

        """
        return _NvRules.IAction_metric_by_name(self, metric_name)


    def add_integer_metric(self, value_name, value_kind, value):
        """
        add_integer_metric(IAction self, char const * value_name, NV::Rules::IMetric::ValueKind value_kind, uint64_t value) -> IMetric

        Parameters
        ----------
        value_name: char const *
        value_kind: enum NV::Rules::IMetric::ValueKind
        value: uint64_t

        """
        return _NvRules.IAction_add_integer_metric(self, value_name, value_kind, value)


    def add_double_metric(self, value_name, value_kind, value):
        """
        add_double_metric(IAction self, char const * value_name, NV::Rules::IMetric::ValueKind value_kind, double value) -> IMetric

        Parameters
        ----------
        value_name: char const *
        value_kind: enum NV::Rules::IMetric::ValueKind
        value: double

        """
        return _NvRules.IAction_add_double_metric(self, value_name, value_kind, value)


    def add_string_metric(self, value_name, value_kind, value):
        """
        add_string_metric(IAction self, char const * value_name, NV::Rules::IMetric::ValueKind value_kind, char const * value) -> IMetric

        Parameters
        ----------
        value_name: char const *
        value_kind: enum NV::Rules::IMetric::ValueKind
        value: char const *

        """
        return _NvRules.IAction_add_string_metric(self, value_name, value_kind, value)

IAction_swigregister = _NvRules.IAction_swigregister
IAction_swigregister(IAction)

class IRange(_object):
    """Proxy of C++ NV::Rules::IRange class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IRange, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IRange, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IRange
    __del__ = lambda self: None

    def num_actions(self):
        """
        num_actions(IRange self) -> size_t

        Parameters
        ----------
        self: NV::Rules::IRange *

        """
        return _NvRules.IRange_num_actions(self)


    def action_by_idx(self, idx):
        """
        action_by_idx(IRange self, size_t idx) -> IAction

        Parameters
        ----------
        idx: size_t

        """
        return _NvRules.IRange_action_by_idx(self, idx)

IRange_swigregister = _NvRules.IRange_swigregister
IRange_swigregister(IRange)

class IFrontend(_object):
    """Proxy of C++ NV::Rules::IFrontend class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IFrontend, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IFrontend, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    MsgType_MSG_NONE = _NvRules.IFrontend_MsgType_MSG_NONE
    MsgType_MSG_OK = _NvRules.IFrontend_MsgType_MSG_OK
    MsgType_MSG_WARNING = _NvRules.IFrontend_MsgType_MSG_WARNING
    MsgType_MSG_ERROR = _NvRules.IFrontend_MsgType_MSG_ERROR
    __swig_destroy__ = _NvRules.delete_IFrontend
    __del__ = lambda self: None

    def message(self, *args):
        """
        message(IFrontend self, char const * str)

        Parameters
        ----------
        str: char const *

        message(IFrontend self, NV::Rules::IFrontend::MsgType type, char const * str)

        Parameters
        ----------
        type: enum NV::Rules::IFrontend::MsgType
        str: char const *

        """
        return _NvRules.IFrontend_message(self, *args)


    def load_chart_from_file(self, filename):
        """
        load_chart_from_file(IFrontend self, char const * filename)

        Parameters
        ----------
        filename: char const *

        """
        return _NvRules.IFrontend_load_chart_from_file(self, filename)

IFrontend_swigregister = _NvRules.IFrontend_swigregister
IFrontend_swigregister(IFrontend)

class IBaseContext(_object):
    """Proxy of C++ NV::Rules::IBaseContext class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IBaseContext, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IBaseContext, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IBaseContext
    __del__ = lambda self: None

    def handle_exception(self, msg):
        """
        handle_exception(IBaseContext self, char const * msg) -> bool

        Parameters
        ----------
        msg: char const *

        """
        return _NvRules.IBaseContext_handle_exception(self, msg)

IBaseContext_swigregister = _NvRules.IBaseContext_swigregister
IBaseContext_swigregister(IBaseContext)

class IController(_object):
    """Proxy of C++ NV::Rules::IController class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IController, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IController, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IController
    __del__ = lambda self: None

    def propose_rule(self, rule):
        """
        propose_rule(IController self, char const * rule)

        Parameters
        ----------
        rule: char const *

        """
        return _NvRules.IController_propose_rule(self, rule)

IController_swigregister = _NvRules.IController_swigregister
IController_swigregister(IController)

class IEvaluator(IBaseContext):
    """Proxy of C++ NV::Rules::IEvaluator class."""

    __swig_setmethods__ = {}
    for _s in [IBaseContext]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IEvaluator, name, value)
    __swig_getmethods__ = {}
    for _s in [IBaseContext]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IEvaluator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IEvaluator
    __del__ = lambda self: None

    def require_metric(self, metric):
        """
        require_metric(IEvaluator self, char const * metric)

        Parameters
        ----------
        metric: char const *

        """
        return _NvRules.IEvaluator_require_metric(self, metric)


    def require_rule(self, rule):
        """
        require_rule(IEvaluator self, char const * rule)

        Parameters
        ----------
        rule: char const *

        """
        return _NvRules.IEvaluator_require_rule(self, rule)

IEvaluator_swigregister = _NvRules.IEvaluator_swigregister
IEvaluator_swigregister(IEvaluator)

class IContext(IBaseContext):
    """Proxy of C++ NV::Rules::IContext class."""

    __swig_setmethods__ = {}
    for _s in [IBaseContext]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IContext, name, value)
    __swig_getmethods__ = {}
    for _s in [IBaseContext]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IContext, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _NvRules.delete_IContext
    __del__ = lambda self: None

    def controller(self):
        """
        controller(IContext self) -> IController

        Parameters
        ----------
        self: NV::Rules::IContext *

        """
        return _NvRules.IContext_controller(self)


    def frontend(self):
        """
        frontend(IContext self) -> IFrontend

        Parameters
        ----------
        self: NV::Rules::IContext *

        """
        return _NvRules.IContext_frontend(self)


    def num_ranges(self):
        """
        num_ranges(IContext self) -> size_t

        Parameters
        ----------
        self: NV::Rules::IContext *

        """
        return _NvRules.IContext_num_ranges(self)


    def range_by_idx(self, idx):
        """
        range_by_idx(IContext self, size_t idx) -> IRange

        Parameters
        ----------
        idx: size_t

        """
        return _NvRules.IContext_range_by_idx(self, idx)

IContext_swigregister = _NvRules.IContext_swigregister
IContext_swigregister(IContext)


def get_context(h):
    """
    get_context(NV::Rules::ContextHandle h) -> IContext

    Parameters
    ----------
    h: NV::Rules::ContextHandle

    """
    return _NvRules.get_context(h)

def get_evaluator(h):
    """
    get_evaluator(NV::Rules::ContextHandle h) -> IEvaluator

    Parameters
    ----------
    h: NV::Rules::ContextHandle

    """
    return _NvRules.get_evaluator(h)

def raise_exception(h, msg):
    """
    raise_exception(IBaseContext h, char const * msg)

    Parameters
    ----------
    h: NV::Rules::IBaseContext *
    msg: char const *

    """
    return _NvRules.raise_exception(h, msg)
# This file is compatible with both classic and new-style classes.



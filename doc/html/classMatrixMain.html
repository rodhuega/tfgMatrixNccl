<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NCCL Matrix Multiplication: Referencia de la plantilla de la Clase MatrixMain&lt; Toperation &gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NCCL Matrix Multiplication
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Buscar');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Buscar');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Métodos públicos</a> &#124;
<a href="#friends">Amigas</a> &#124;
<a href="classMatrixMain-members.html">Lista de todos los miembros</a>  </div>
  <div class="headertitle">
<div class="title">Referencia de la plantilla de la Clase MatrixMain&lt; Toperation &gt;</div>  </div>
</div><!--header-->
<div class="contents">

<p>Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella.  
 <a href="classMatrixMain.html#details">Más...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Métodos públicos</h2></td></tr>
<tr class="memitem:a0ffc21ba65bbd7b6018e11550b0f27f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a0ffc21ba65bbd7b6018e11550b0f27f5">MatrixMain</a> (<a class="el" href="classNcclMultiplicationEnvironment.html">NcclMultiplicationEnvironment</a>&lt; Toperation &gt; *ncclMultEnv, int rows, int columns)</td></tr>
<tr class="memdesc:a0ffc21ba65bbd7b6018e11550b0f27f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor de <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a>. Crea una <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a> y la asigna a un <a class="el" href="classNcclMultiplicationEnvironment.html" title="Clase estática que contiene a las matrices y las características necesarias para realizar la múltipli...">NcclMultiplicationEnvironment</a>.  <a href="#a0ffc21ba65bbd7b6018e11550b0f27f5">Más...</a><br /></td></tr>
<tr class="separator:a0ffc21ba65bbd7b6018e11550b0f27f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b43cb57acbd5a1cd971d593a9e7815"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#aa7b43cb57acbd5a1cd971d593a9e7815">MatrixMain</a> (<a class="el" href="classNcclMultiplicationEnvironment.html">NcclMultiplicationEnvironment</a>&lt; Toperation &gt; *ncclMultEnv, int rows, int columns, Toperation *matrix)</td></tr>
<tr class="memdesc:aa7b43cb57acbd5a1cd971d593a9e7815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor de <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a>. Crea una <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a> y la asigna a un <a class="el" href="classNcclMultiplicationEnvironment.html" title="Clase estática que contiene a las matrices y las características necesarias para realizar la múltipli...">NcclMultiplicationEnvironment</a>.  <a href="#aa7b43cb57acbd5a1cd971d593a9e7815">Más...</a><br /></td></tr>
<tr class="separator:aa7b43cb57acbd5a1cd971d593a9e7815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93a59c6dab2de24c2f2a60f1f6f95f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ab93a59c6dab2de24c2f2a60f1f6f95f2">MatrixMain</a> (const <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;maMain)</td></tr>
<tr class="memdesc:ab93a59c6dab2de24c2f2a60f1f6f95f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor de <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a> a partir de otro. Copia profunda de la matriz del host si la hay y de sus gpuWorkers.  <a href="#ab93a59c6dab2de24c2f2a60f1f6f95f2">Más...</a><br /></td></tr>
<tr class="separator:ab93a59c6dab2de24c2f2a60f1f6f95f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a0bd559991c8372bb6a782d646c328"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ac4a0bd559991c8372bb6a782d646c328">MatrixMain</a> (<a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&amp;B)</td></tr>
<tr class="memdesc:ac4a0bd559991c8372bb6a782d646c328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor de <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a> de movimiento.  <a href="#ac4a0bd559991c8372bb6a782d646c328">Más...</a><br /></td></tr>
<tr class="separator:ac4a0bd559991c8372bb6a782d646c328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f27375e3180a2894633a5b6477529d"><td class="memItemLeft" align="right" valign="top"><a id="a82f27375e3180a2894633a5b6477529d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a82f27375e3180a2894633a5b6477529d">~MatrixMain</a> ()</td></tr>
<tr class="memdesc:a82f27375e3180a2894633a5b6477529d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor de <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a> que elimina todos los gpuWorkers asociados. Si se ha activado antes el flag correspondiente a true mediante <a class="el" href="classMatrixMain.html#a9c8cf3be535a8bb042f6ee0ddaafc6b1" title="Asigna si se destruirá la matriz del host cuando se destruya el objeto. ">setDeleteMatrixHostAtDestroyment()</a> también elimina el puntero de la matriz host en caso de que exista. <br /></td></tr>
<tr class="separator:a82f27375e3180a2894633a5b6477529d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa158ccbaecfba4cbafa36bc424f321e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#aaa158ccbaecfba4cbafa36bc424f321e">getIsDistributed</a> ()</td></tr>
<tr class="memdesc:aaa158ccbaecfba4cbafa36bc424f321e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indica si una matriz esta distribuida o no.  <a href="#aaa158ccbaecfba4cbafa36bc424f321e">Más...</a><br /></td></tr>
<tr class="separator:aaa158ccbaecfba4cbafa36bc424f321e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d936d844e9b03ff05979220be754461"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a0d936d844e9b03ff05979220be754461">getRowsReal</a> ()</td></tr>
<tr class="memdesc:a0d936d844e9b03ff05979220be754461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el valor de filas reales de la verdadera matriz.  <a href="#a0d936d844e9b03ff05979220be754461">Más...</a><br /></td></tr>
<tr class="separator:a0d936d844e9b03ff05979220be754461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fbed871925f5f34b40b0a264b4eff6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a51fbed871925f5f34b40b0a264b4eff6">getRowsUsed</a> ()</td></tr>
<tr class="memdesc:a51fbed871925f5f34b40b0a264b4eff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el valor de filas que se usará para operar, en caso de no con coincidir con columnsReal significa que el exceso son 0.  <a href="#a51fbed871925f5f34b40b0a264b4eff6">Más...</a><br /></td></tr>
<tr class="separator:a51fbed871925f5f34b40b0a264b4eff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0f90b2eaf866d16b3e3ade9170dab4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#aae0f90b2eaf866d16b3e3ade9170dab4">getColumnsReal</a> ()</td></tr>
<tr class="memdesc:aae0f90b2eaf866d16b3e3ade9170dab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el valor de columnas reales de la verdadera matriz.  <a href="#aae0f90b2eaf866d16b3e3ade9170dab4">Más...</a><br /></td></tr>
<tr class="separator:aae0f90b2eaf866d16b3e3ade9170dab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b10c2d369328d9254fdc7a435f173f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a82b10c2d369328d9254fdc7a435f173f">getColumnsUsed</a> ()</td></tr>
<tr class="memdesc:a82b10c2d369328d9254fdc7a435f173f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el valor de columnas que se usará para operar, en caso de no con coincidir con columnsReal significa que el exceso son 0.  <a href="#a82b10c2d369328d9254fdc7a435f173f">Más...</a><br /></td></tr>
<tr class="separator:a82b10c2d369328d9254fdc7a435f173f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa838ad93f6915c9425de28416cfd28af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#aa838ad93f6915c9425de28416cfd28af">getBlockSize</a> ()</td></tr>
<tr class="memdesc:aa838ad93f6915c9425de28416cfd28af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el valor de blockSize.  <a href="#aa838ad93f6915c9425de28416cfd28af">Más...</a><br /></td></tr>
<tr class="separator:aa838ad93f6915c9425de28416cfd28af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30c2ac0e3100c1e248fbdc1bcbb146c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ab30c2ac0e3100c1e248fbdc1bcbb146c">getBlockRowSize</a> ()</td></tr>
<tr class="memdesc:ab30c2ac0e3100c1e248fbdc1bcbb146c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el valor de blockRowSize.  <a href="#ab30c2ac0e3100c1e248fbdc1bcbb146c">Más...</a><br /></td></tr>
<tr class="separator:ab30c2ac0e3100c1e248fbdc1bcbb146c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dafe8a675361da10486c8c7b3e16cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ad2dafe8a675361da10486c8c7b3e16cd">getBlockColumnSize</a> ()</td></tr>
<tr class="memdesc:ad2dafe8a675361da10486c8c7b3e16cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el valor de blockColumnSize.  <a href="#ad2dafe8a675361da10486c8c7b3e16cd">Más...</a><br /></td></tr>
<tr class="separator:ad2dafe8a675361da10486c8c7b3e16cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b92a3021af1891db86cf8041cea5b84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a1b92a3021af1891db86cf8041cea5b84">getMeshColumnSize</a> ()</td></tr>
<tr class="memdesc:a1b92a3021af1891db86cf8041cea5b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el tamaño de la malla de las columnas.  <a href="#a1b92a3021af1891db86cf8041cea5b84">Más...</a><br /></td></tr>
<tr class="separator:a1b92a3021af1891db86cf8041cea5b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d8f63bf41a6ba3d77dfddda7d891db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ab7d8f63bf41a6ba3d77dfddda7d891db">getMeshRowSize</a> ()</td></tr>
<tr class="memdesc:ab7d8f63bf41a6ba3d77dfddda7d891db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el tamaño de la malla de las filas.  <a href="#ab7d8f63bf41a6ba3d77dfddda7d891db">Más...</a><br /></td></tr>
<tr class="separator:ab7d8f63bf41a6ba3d77dfddda7d891db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300c5ebe0494dde69fe7b8bc3a63ad0b"><td class="memItemLeft" align="right" valign="top">Toperation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a300c5ebe0494dde69fe7b8bc3a63ad0b">getAlphaGemm</a> ()</td></tr>
<tr class="memdesc:a300c5ebe0494dde69fe7b8bc3a63ad0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el valor del escalar alfa en la operacion GEMM.  <a href="#a300c5ebe0494dde69fe7b8bc3a63ad0b">Más...</a><br /></td></tr>
<tr class="separator:a300c5ebe0494dde69fe7b8bc3a63ad0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e00fc3ae8e8c9f0f4acafea1c277896"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a6e00fc3ae8e8c9f0f4acafea1c277896">getIsMatrixHostHere</a> ()</td></tr>
<tr class="memdesc:a6e00fc3ae8e8c9f0f4acafea1c277896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indica si hay una matriz global.  <a href="#a6e00fc3ae8e8c9f0f4acafea1c277896">Más...</a><br /></td></tr>
<tr class="separator:a6e00fc3ae8e8c9f0f4acafea1c277896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6337937413c1ad5660373ab23b1b40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ada6337937413c1ad5660373ab23b1b40">getDeleteMatrixHostAtDestroyment</a> ()</td></tr>
<tr class="memdesc:ada6337937413c1ad5660373ab23b1b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indica si se destruirá la matriz del host cuando se elimine el objeto.  <a href="#ada6337937413c1ad5660373ab23b1b40">Más...</a><br /></td></tr>
<tr class="separator:ada6337937413c1ad5660373ab23b1b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fdb08ac465293c535168c626ab181d"><td class="memItemLeft" align="right" valign="top">Toperation *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a34fdb08ac465293c535168c626ab181d">getHostMatrix</a> ()</td></tr>
<tr class="memdesc:a34fdb08ac465293c535168c626ab181d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene el puntero de la matriz global del host.  <a href="#a34fdb08ac465293c535168c626ab181d">Más...</a><br /></td></tr>
<tr class="separator:a34fdb08ac465293c535168c626ab181d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53a94f43e0c1544a497cb238aaaa364"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ad53a94f43e0c1544a497cb238aaaa364">getHostMatrixInThisPointer</a> (Toperation *pointerMatrix)</td></tr>
<tr class="memdesc:ad53a94f43e0c1544a497cb238aaaa364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copia la matriz al puntero del host que se pasa como argumento.  <a href="#ad53a94f43e0c1544a497cb238aaaa364">Más...</a><br /></td></tr>
<tr class="separator:ad53a94f43e0c1544a497cb238aaaa364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627cb55a45b1a2618387483d24878d63"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classGpuWorker.html">GpuWorker</a>&lt; Toperation &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a627cb55a45b1a2618387483d24878d63">getGpuWorkers</a> ()</td></tr>
<tr class="memdesc:a627cb55a45b1a2618387483d24878d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtiene todos los gpuWorkers de la matriz.  <a href="#a627cb55a45b1a2618387483d24878d63">Más...</a><br /></td></tr>
<tr class="separator:a627cb55a45b1a2618387483d24878d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed24dfbeb31237e66b29e13a66ce2ef2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#aed24dfbeb31237e66b29e13a66ce2ef2">setRowsUsed</a> (int rowsUsed)</td></tr>
<tr class="memdesc:aed24dfbeb31237e66b29e13a66ce2ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asigna el valor de filas que se usará para operar, en caso de no con coincidir con columnsReal significa que el exceso son 0.  <a href="#aed24dfbeb31237e66b29e13a66ce2ef2">Más...</a><br /></td></tr>
<tr class="separator:aed24dfbeb31237e66b29e13a66ce2ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85480f53c9b1deea09d5fbed1a48d2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#aa85480f53c9b1deea09d5fbed1a48d2e">setColumnsUsed</a> (int columnsUsed)</td></tr>
<tr class="memdesc:aa85480f53c9b1deea09d5fbed1a48d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asigna el valor de columnas que se usará para operar, en caso de no con coincidir con columnsReal significa que el exceso son 0.  <a href="#aa85480f53c9b1deea09d5fbed1a48d2e">Más...</a><br /></td></tr>
<tr class="separator:aa85480f53c9b1deea09d5fbed1a48d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e67efda03cdd8e70215247b7f857002"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a6e67efda03cdd8e70215247b7f857002">setAlphaGemm</a> (Toperation alphaGemm)</td></tr>
<tr class="memdesc:a6e67efda03cdd8e70215247b7f857002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asigna el valor del escalar alfa para la operacion GEMM.  <a href="#a6e67efda03cdd8e70215247b7f857002">Más...</a><br /></td></tr>
<tr class="separator:a6e67efda03cdd8e70215247b7f857002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efed0175fedf515e3356ea3c27d3d5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a6efed0175fedf515e3356ea3c27d3d5a">setIsMatrixHostHere</a> (bool isMatrixHostHere)</td></tr>
<tr class="memdesc:a6efed0175fedf515e3356ea3c27d3d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asigna si hay una matriz en el host. En caso de que se asigne que no y este la matriz, se liberan recursos y se asigna nullptr.  <a href="#a6efed0175fedf515e3356ea3c27d3d5a">Más...</a><br /></td></tr>
<tr class="separator:a6efed0175fedf515e3356ea3c27d3d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbc27697a76770978dde0e4b0edc732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a1cbc27697a76770978dde0e4b0edc732">setMatrixHost</a> (Toperation *newMatrixHost)</td></tr>
<tr class="memdesc:a1cbc27697a76770978dde0e4b0edc732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asigna una nueva matriz a matrixHost y destruye los gpuWorkers que existían antes y la matrixHost que hubiese antes.  <a href="#a1cbc27697a76770978dde0e4b0edc732">Más...</a><br /></td></tr>
<tr class="separator:a1cbc27697a76770978dde0e4b0edc732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fa4a668ce7857289dc0931b319429e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#aa6fa4a668ce7857289dc0931b319429e">setMatrixHostToFullValue</a> (Toperation valueForHost)</td></tr>
<tr class="memdesc:aa6fa4a668ce7857289dc0931b319429e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asigna un valor a todos los elementos de la matriz de matrixHost. Elimina la que había con anterioridad.  <a href="#aa6fa4a668ce7857289dc0931b319429e">Más...</a><br /></td></tr>
<tr class="separator:aa6fa4a668ce7857289dc0931b319429e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8cf3be535a8bb042f6ee0ddaafc6b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a9c8cf3be535a8bb042f6ee0ddaafc6b1">setDeleteMatrixHostAtDestroyment</a> (bool deleteMatrixHostAtDestroyment)</td></tr>
<tr class="memdesc:a9c8cf3be535a8bb042f6ee0ddaafc6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asigna si se destruirá la matriz del host cuando se destruya el objeto.  <a href="#a9c8cf3be535a8bb042f6ee0ddaafc6b1">Más...</a><br /></td></tr>
<tr class="separator:a9c8cf3be535a8bb042f6ee0ddaafc6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c00132316f5c4c39259281d8e9d3e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a8c00132316f5c4c39259281d8e9d3e95">setIsDistributed</a> (bool isDistributed)</td></tr>
<tr class="memdesc:a8c00132316f5c4c39259281d8e9d3e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asigna si una matriz está distribuida o no.  <a href="#a8c00132316f5c4c39259281d8e9d3e95">Más...</a><br /></td></tr>
<tr class="separator:a8c00132316f5c4c39259281d8e9d3e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955eceba34f3a4b617a6fab1a97159cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a955eceba34f3a4b617a6fab1a97159cd">setMatrixOperationProperties</a> (int meshRowSize, int meshColumnSize, int blockRowSize, int blockColumnSize)</td></tr>
<tr class="memdesc:a955eceba34f3a4b617a6fab1a97159cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asigna las propiedades de la matriz para la operacion que se va a realizar.  <a href="#a955eceba34f3a4b617a6fab1a97159cd">Más...</a><br /></td></tr>
<tr class="separator:a955eceba34f3a4b617a6fab1a97159cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45d7ed84d54e7ff0f78898fe6441915"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#aa45d7ed84d54e7ff0f78898fe6441915">calculateRowColor</a> (int gpuRank)</td></tr>
<tr class="memdesc:aa45d7ed84d54e7ff0f78898fe6441915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcula el color de la fila respecto el rango de la gpu dado en la matriz.  <a href="#aa45d7ed84d54e7ff0f78898fe6441915">Más...</a><br /></td></tr>
<tr class="separator:aa45d7ed84d54e7ff0f78898fe6441915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d6d01aecf191f9d4d3045e7f5f9feb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a52d6d01aecf191f9d4d3045e7f5f9feb">calculateColumnColor</a> (int gpuRank)</td></tr>
<tr class="memdesc:a52d6d01aecf191f9d4d3045e7f5f9feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcula el color de la columna respecto el rango de la gpu dado en la matriz.  <a href="#a52d6d01aecf191f9d4d3045e7f5f9feb">Más...</a><br /></td></tr>
<tr class="separator:a52d6d01aecf191f9d4d3045e7f5f9feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412ed02c2cf14dcada84239e68d1a1a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a412ed02c2cf14dcada84239e68d1a1a3">calculateBlockDimensionToCopy</a> (int color, int meshDimensionSize, int blockDimenensionSize, int dimensionUsed, int dimensionReal)</td></tr>
<tr class="memdesc:a412ed02c2cf14dcada84239e68d1a1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve la longitud de número de elementos que hay que copiar.  <a href="#a412ed02c2cf14dcada84239e68d1a1a3">Más...</a><br /></td></tr>
<tr class="separator:a412ed02c2cf14dcada84239e68d1a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb7a40ddf04ad2f3544105ef53353d9"><td class="memItemLeft" align="right" valign="top"><a id="a9eb7a40ddf04ad2f3544105ef53353d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a9eb7a40ddf04ad2f3544105ef53353d9">waitAllStreamsOfAllWorkers</a> ()</td></tr>
<tr class="memdesc:a9eb7a40ddf04ad2f3544105ef53353d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Espera a que acaben todos los streams de los GpuWorkers(gpus lógicas) <br /></td></tr>
<tr class="separator:a9eb7a40ddf04ad2f3544105ef53353d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3e50c4ba5173abbbc4c0b90c9e546d"><td class="memItemLeft" align="right" valign="top"><a id="a5b3e50c4ba5173abbbc4c0b90c9e546d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a5b3e50c4ba5173abbbc4c0b90c9e546d">distributeMatrixIntoGpus</a> ()</td></tr>
<tr class="memdesc:a5b3e50c4ba5173abbbc4c0b90c9e546d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribuye la matriz del host a las gpus. <br /></td></tr>
<tr class="separator:a5b3e50c4ba5173abbbc4c0b90c9e546d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4ecdca5f601c0f2a05a6cafc9eea18"><td class="memItemLeft" align="right" valign="top"><a id="a7e4ecdca5f601c0f2a05a6cafc9eea18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a7e4ecdca5f601c0f2a05a6cafc9eea18">distributeMatrixMySelfIntoGpus</a> ()</td></tr>
<tr class="memdesc:a7e4ecdca5f601c0f2a05a6cafc9eea18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribuye la matriz del host a la gpu como si se multiplicase consigo misma. <br /></td></tr>
<tr class="separator:a7e4ecdca5f601c0f2a05a6cafc9eea18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b3657c7ce39feb11815971d2ec1382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ac7b3657c7ce39feb11815971d2ec1382">recoverMatrixToHost</a> (Toperation *pointerMatrix)</td></tr>
<tr class="memdesc:ac7b3657c7ce39feb11815971d2ec1382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve la matriz de las gpus al host en el puntero indicado.  <a href="#ac7b3657c7ce39feb11815971d2ec1382">Más...</a><br /></td></tr>
<tr class="separator:ac7b3657c7ce39feb11815971d2ec1382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9debccd89809647c28ad214434aaebb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#af9debccd89809647c28ad214434aaebb">axpy</a> (const Toperation &amp;alpha, <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;X)</td></tr>
<tr class="memdesc:af9debccd89809647c28ad214434aaebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Realización de la operación axpy entre dos matrices(suma), la matriz actual a la cual se le va a sumar X.  <a href="#af9debccd89809647c28ad214434aaebb">Más...</a><br /></td></tr>
<tr class="separator:af9debccd89809647c28ad214434aaebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78ea69222a13a6ef322573b82427787"><td class="memItemLeft" align="right" valign="top">Toperation&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ad78ea69222a13a6ef322573b82427787">norm1</a> ()</td></tr>
<tr class="memdesc:ad78ea69222a13a6ef322573b82427787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcula y devuelve la norma 1 de una matriz. Máxima suma de sus columnas.  <a href="#ad78ea69222a13a6ef322573b82427787">Más...</a><br /></td></tr>
<tr class="separator:ad78ea69222a13a6ef322573b82427787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcca620fc49b59d8aaf1171b6b0ba6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a5dcca620fc49b59d8aaf1171b6b0ba6f">operator*=</a> (<a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;B)</td></tr>
<tr class="memdesc:a5dcca620fc49b59d8aaf1171b6b0ba6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador *= (multiplicación y asignación) en caso entre matrices.  <a href="#a5dcca620fc49b59d8aaf1171b6b0ba6f">Más...</a><br /></td></tr>
<tr class="separator:a5dcca620fc49b59d8aaf1171b6b0ba6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bb905f0b2d52709331ff0e3ec6733b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a89bb905f0b2d52709331ff0e3ec6733b">operator*</a> (<a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;B)</td></tr>
<tr class="memdesc:a89bb905f0b2d52709331ff0e3ec6733b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador * (multiplicación) en caso entre matrices.  <a href="#a89bb905f0b2d52709331ff0e3ec6733b">Más...</a><br /></td></tr>
<tr class="separator:a89bb905f0b2d52709331ff0e3ec6733b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a843f990bf1fd8bf644780bac68b46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ab1a843f990bf1fd8bf644780bac68b46">operator*=</a> (const Toperation &amp;alpha)</td></tr>
<tr class="memdesc:ab1a843f990bf1fd8bf644780bac68b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador *= (multiplicación y asignación) en caso de un escalar.  <a href="#ab1a843f990bf1fd8bf644780bac68b46">Más...</a><br /></td></tr>
<tr class="separator:ab1a843f990bf1fd8bf644780bac68b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2192d54d74edc3e7b2fce277fd2a214f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a2192d54d74edc3e7b2fce277fd2a214f">operator*</a> (const Toperation &amp;alpha)</td></tr>
<tr class="memdesc:a2192d54d74edc3e7b2fce277fd2a214f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador * (multiplicación) en caso de un escalar.  <a href="#a2192d54d74edc3e7b2fce277fd2a214f">Más...</a><br /></td></tr>
<tr class="separator:a2192d54d74edc3e7b2fce277fd2a214f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7533eb0bf566b392286134979c2240f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a7533eb0bf566b392286134979c2240f7">operator/=</a> (const Toperation &amp;alpha)</td></tr>
<tr class="memdesc:a7533eb0bf566b392286134979c2240f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador *= (dividir y asignación) en caso de un escalar.  <a href="#a7533eb0bf566b392286134979c2240f7">Más...</a><br /></td></tr>
<tr class="separator:a7533eb0bf566b392286134979c2240f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18465b7a138010a03901c266f8aa306"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#aa18465b7a138010a03901c266f8aa306">operator/</a> (const Toperation &amp;alpha)</td></tr>
<tr class="memdesc:aa18465b7a138010a03901c266f8aa306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador / (división) en caso de un escalar.  <a href="#aa18465b7a138010a03901c266f8aa306">Más...</a><br /></td></tr>
<tr class="separator:aa18465b7a138010a03901c266f8aa306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5bc59c186622de3497b5d70f4ac6af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a7b5bc59c186622de3497b5d70f4ac6af">operator=</a> (const <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;B)</td></tr>
<tr class="memdesc:a7b5bc59c186622de3497b5d70f4ac6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override de asignación (=) de <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a>.  <a href="#a7b5bc59c186622de3497b5d70f4ac6af">Más...</a><br /></td></tr>
<tr class="separator:a7b5bc59c186622de3497b5d70f4ac6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04803e3d88409e75bf45dfde76b640b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a04803e3d88409e75bf45dfde76b640b5">operator=</a> (<a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&amp;B)</td></tr>
<tr class="memdesc:a04803e3d88409e75bf45dfde76b640b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asignación de movimiento.  <a href="#a04803e3d88409e75bf45dfde76b640b5">Más...</a><br /></td></tr>
<tr class="separator:a04803e3d88409e75bf45dfde76b640b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4235d9cb94762af7d7fcf9d3185ae5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a9c4235d9cb94762af7d7fcf9d3185ae5">operator+=</a> (const Toperation &amp;constantAddition)</td></tr>
<tr class="memdesc:a9c4235d9cb94762af7d7fcf9d3185ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador +=(suma y asignación) de una matriz + la identidad multiplicada por una constante.  <a href="#a9c4235d9cb94762af7d7fcf9d3185ae5">Más...</a><br /></td></tr>
<tr class="separator:a9c4235d9cb94762af7d7fcf9d3185ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1bc3c2ee26975fe979213d9d177608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a0c1bc3c2ee26975fe979213d9d177608">operator+</a> (const Toperation &amp;constantAddition)</td></tr>
<tr class="memdesc:a0c1bc3c2ee26975fe979213d9d177608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador + (suma) de una matriz + la identidad multiplicada por una constante.  <a href="#a0c1bc3c2ee26975fe979213d9d177608">Más...</a><br /></td></tr>
<tr class="separator:a0c1bc3c2ee26975fe979213d9d177608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c163a3002d2e8de1e05dcac5ea5df1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ac5c163a3002d2e8de1e05dcac5ea5df1">operator-=</a> (const Toperation &amp;constantSubstraction)</td></tr>
<tr class="memdesc:ac5c163a3002d2e8de1e05dcac5ea5df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador -= (resta y asignación) de una matriz - la identidad multiplicada por una constante.  <a href="#ac5c163a3002d2e8de1e05dcac5ea5df1">Más...</a><br /></td></tr>
<tr class="separator:ac5c163a3002d2e8de1e05dcac5ea5df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9105969d693cab31a797b1f5c7e63d69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a9105969d693cab31a797b1f5c7e63d69">operator-</a> (const Toperation &amp;constantSubstraction)</td></tr>
<tr class="memdesc:a9105969d693cab31a797b1f5c7e63d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador - (resta) de una matriz - la identidad multiplicada por una constante.  <a href="#a9105969d693cab31a797b1f5c7e63d69">Más...</a><br /></td></tr>
<tr class="separator:a9105969d693cab31a797b1f5c7e63d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f89e678cec819cbeffdf363a4bf717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ac4f89e678cec819cbeffdf363a4bf717">operator+=</a> (<a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;maMain)</td></tr>
<tr class="memdesc:ac4f89e678cec819cbeffdf363a4bf717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador +=(suma y asignación) de una matriz + otra matriz.  <a href="#ac4f89e678cec819cbeffdf363a4bf717">Más...</a><br /></td></tr>
<tr class="separator:ac4f89e678cec819cbeffdf363a4bf717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c27bc4800c921cc22ad5aa3c159b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a16c27bc4800c921cc22ad5aa3c159b11">operator+</a> (<a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;maMain)</td></tr>
<tr class="memdesc:a16c27bc4800c921cc22ad5aa3c159b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador +(suma) de una matriz + otra matriz.  <a href="#a16c27bc4800c921cc22ad5aa3c159b11">Más...</a><br /></td></tr>
<tr class="separator:a16c27bc4800c921cc22ad5aa3c159b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c12a483991f3b4d90f95e1ca09a4174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a9c12a483991f3b4d90f95e1ca09a4174">operator-=</a> (<a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;maMain)</td></tr>
<tr class="memdesc:a9c12a483991f3b4d90f95e1ca09a4174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador -=(resta y asignación) de una matriz - otra matriz.  <a href="#a9c12a483991f3b4d90f95e1ca09a4174">Más...</a><br /></td></tr>
<tr class="separator:a9c12a483991f3b4d90f95e1ca09a4174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ec4e4edf0d77e97cd8b4c8ecfc32ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#ac3ec4e4edf0d77e97cd8b4c8ecfc32ee">operator-</a> (<a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;maMain)</td></tr>
<tr class="memdesc:ac3ec4e4edf0d77e97cd8b4c8ecfc32ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador -(resta) de una matriz - otra matriz.  <a href="#ac3ec4e4edf0d77e97cd8b4c8ecfc32ee">Más...</a><br /></td></tr>
<tr class="separator:ac3ec4e4edf0d77e97cd8b4c8ecfc32ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5fed2f8190d857c39ed911601910c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#aef5fed2f8190d857c39ed911601910c2">operator-</a> ()</td></tr>
<tr class="memdesc:aef5fed2f8190d857c39ed911601910c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador del cambio de signo -. Cambia el signo de todos los elementos de una matriz.  <a href="#aef5fed2f8190d857c39ed911601910c2">Más...</a><br /></td></tr>
<tr class="separator:aef5fed2f8190d857c39ed911601910c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Amigas</h2></td></tr>
<tr class="memitem:a83759ded6e3b7e9182b65f7ad77853a8"><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr class="memitem:a83759ded6e3b7e9182b65f7ad77853a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a83759ded6e3b7e9182b65f7ad77853a8">operator+</a> (const double &amp;constantAddition, const <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; To &gt; &amp;maMain)</td></tr>
<tr class="memdesc:a83759ded6e3b7e9182b65f7ad77853a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador + (suma) de la identidad multiplicada por un número y otra matriz.  <a href="#a83759ded6e3b7e9182b65f7ad77853a8">Más...</a><br /></td></tr>
<tr class="separator:a83759ded6e3b7e9182b65f7ad77853a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc3df8f6d3a91a9e8e23005d0a099e2"><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr class="memitem:addc3df8f6d3a91a9e8e23005d0a099e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#addc3df8f6d3a91a9e8e23005d0a099e2">operator*</a> (const double &amp;alpha, const <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; To &gt; &amp;maMain)</td></tr>
<tr class="memdesc:addc3df8f6d3a91a9e8e23005d0a099e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador * (multiplicación) en caso de un escalar. Escalar * matriz.  <a href="#addc3df8f6d3a91a9e8e23005d0a099e2">Más...</a><br /></td></tr>
<tr class="separator:addc3df8f6d3a91a9e8e23005d0a099e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ae6469adf07f6a6b0f220beab3ed1d"><td class="memTemplParams" colspan="2">template&lt;typename To &gt; </td></tr>
<tr class="memitem:a01ae6469adf07f6a6b0f220beab3ed1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMatrixMain.html#a01ae6469adf07f6a6b0f220beab3ed1d">operator-</a> (const double &amp;constantSubstraction, const <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; To &gt; &amp;maMain)</td></tr>
<tr class="memdesc:a01ae6469adf07f6a6b0f220beab3ed1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override del operador + (suma) de la identidad multiplicada por un número y otra matriz.  <a href="#a01ae6469adf07f6a6b0f220beab3ed1d">Más...</a><br /></td></tr>
<tr class="separator:a01ae6469adf07f6a6b0f220beab3ed1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descripción detallada</h2>
<div class="textblock"><h3>template&lt;class Toperation&gt;<br />
class MatrixMain&lt; Toperation &gt;</h3>

<p>Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella. </p>
<dl class="tparams"><dt>Parámetros del template</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Toperation,tipo</td><td>de la matriz(double,float) </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Documentación del constructor y destructor</h2>
<a id="a0ffc21ba65bbd7b6018e11550b0f27f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffc21ba65bbd7b6018e11550b0f27f5">&#9670;&nbsp;</a></span>MatrixMain() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::<a class="el" href="classMatrixMain.html">MatrixMain</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNcclMultiplicationEnvironment.html">NcclMultiplicationEnvironment</a>&lt; Toperation &gt; *&#160;</td>
          <td class="paramname"><em>ncclMultEnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor de <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a>. Crea una <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a> y la asigna a un <a class="el" href="classNcclMultiplicationEnvironment.html" title="Clase estática que contiene a las matrices y las características necesarias para realizar la múltipli...">NcclMultiplicationEnvironment</a>. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncclMultEnv,Entorno</td><td>donde se usará esta matriz </td></tr>
    <tr><td class="paramname">rows,filas</td><td>reales de la matriz </td></tr>
    <tr><td class="paramname">columns,columnas</td><td>reales de la matriz </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7b43cb57acbd5a1cd971d593a9e7815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b43cb57acbd5a1cd971d593a9e7815">&#9670;&nbsp;</a></span>MatrixMain() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::<a class="el" href="classMatrixMain.html">MatrixMain</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNcclMultiplicationEnvironment.html">NcclMultiplicationEnvironment</a>&lt; Toperation &gt; *&#160;</td>
          <td class="paramname"><em>ncclMultEnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Toperation *&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor de <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a>. Crea una <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a> y la asigna a un <a class="el" href="classNcclMultiplicationEnvironment.html" title="Clase estática que contiene a las matrices y las características necesarias para realizar la múltipli...">NcclMultiplicationEnvironment</a>. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncclMultEnv,Entorno</td><td>donde se usará esta matriz </td></tr>
    <tr><td class="paramname">rows,filas</td><td>reales de la matriz </td></tr>
    <tr><td class="paramname">columns,columnas</td><td>reales de la matriz </td></tr>
    <tr><td class="paramname">*matrix,puntero</td><td>de la matriz host </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab93a59c6dab2de24c2f2a60f1f6f95f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93a59c6dab2de24c2f2a60f1f6f95f2">&#9670;&nbsp;</a></span>MatrixMain() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::<a class="el" href="classMatrixMain.html">MatrixMain</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td>
          <td class="paramname"><em>maMain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor de <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a> a partir de otro. Copia profunda de la matriz del host si la hay y de sus gpuWorkers. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">maMain,<a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a></td><td>del cual se va a copiar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4a0bd559991c8372bb6a782d646c328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a0bd559991c8372bb6a782d646c328">&#9670;&nbsp;</a></span>MatrixMain() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::<a class="el" href="classMatrixMain.html">MatrixMain</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor de <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a> de movimiento. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Documentación de las funciones miembro</h2>
<a id="af9debccd89809647c28ad214434aaebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9debccd89809647c28ad214434aaebb">&#9670;&nbsp;</a></span>axpy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::axpy </td>
          <td>(</td>
          <td class="paramtype">const Toperation &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Realización de la operación axpy entre dos matrices(suma), la matriz actual a la cual se le va a sumar X. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha,escalar</td><td>que multiplicará a X </td></tr>
    <tr><td class="paramname">X,matriz</td><td>que se sumará a X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a412ed02c2cf14dcada84239e68d1a1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412ed02c2cf14dcada84239e68d1a1a3">&#9670;&nbsp;</a></span>calculateBlockDimensionToCopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::calculateBlockDimensionToCopy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshDimensionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockDimenensionSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensionUsed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dimensionReal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve la longitud de número de elementos que hay que copiar. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">color,color</td><td>del bloque de la matriz, Fila o columna a la que pertenece en la matriz global </td></tr>
    <tr><td class="paramname">meshDimensionSize,tamaño</td><td>de la dimensión de la malla </td></tr>
    <tr><td class="paramname">blockDimenensionSize,tamaño</td><td>de la dimensión elegida de ese bloque </td></tr>
    <tr><td class="paramname">dimensionUsed,tamaño</td><td>de la dimensión elegida en la matriz global con la que se opera(0s incluidos) </td></tr>
    <tr><td class="paramname">dimensionReal,tamaño</td><td>real de la dimensión elegida en la matriz global(0s no incluidos) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="a52d6d01aecf191f9d4d3045e7f5f9feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d6d01aecf191f9d4d3045e7f5f9feb">&#9670;&nbsp;</a></span>calculateColumnColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::calculateColumnColor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gpuRank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcula el color de la columna respecto el rango de la gpu dado en la matriz. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpuRank,rango</td><td>de la gpu </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="aa45d7ed84d54e7ff0f78898fe6441915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45d7ed84d54e7ff0f78898fe6441915">&#9670;&nbsp;</a></span>calculateRowColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::calculateRowColor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gpuRank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcula el color de la fila respecto el rango de la gpu dado en la matriz. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpuRank,rango</td><td>de la gpu </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="a300c5ebe0494dde69fe7b8bc3a63ad0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300c5ebe0494dde69fe7b8bc3a63ad0b">&#9670;&nbsp;</a></span>getAlphaGemm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Toperation <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getAlphaGemm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el valor del escalar alfa en la operacion GEMM. </p>
<dl class="section return"><dt>Devuelve</dt><dd>Toperation </dd></dl>

</div>
</div>
<a id="ad2dafe8a675361da10486c8c7b3e16cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dafe8a675361da10486c8c7b3e16cd">&#9670;&nbsp;</a></span>getBlockColumnSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getBlockColumnSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el valor de blockColumnSize. </p>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="ab30c2ac0e3100c1e248fbdc1bcbb146c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30c2ac0e3100c1e248fbdc1bcbb146c">&#9670;&nbsp;</a></span>getBlockRowSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getBlockRowSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el valor de blockRowSize. </p>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="aa838ad93f6915c9425de28416cfd28af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa838ad93f6915c9425de28416cfd28af">&#9670;&nbsp;</a></span>getBlockSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el valor de blockSize. </p>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="aae0f90b2eaf866d16b3e3ade9170dab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0f90b2eaf866d16b3e3ade9170dab4">&#9670;&nbsp;</a></span>getColumnsReal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getColumnsReal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el valor de columnas reales de la verdadera matriz. </p>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="a82b10c2d369328d9254fdc7a435f173f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b10c2d369328d9254fdc7a435f173f">&#9670;&nbsp;</a></span>getColumnsUsed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getColumnsUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el valor de columnas que se usará para operar, en caso de no con coincidir con columnsReal significa que el exceso son 0. </p>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="ada6337937413c1ad5660373ab23b1b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6337937413c1ad5660373ab23b1b40">&#9670;&nbsp;</a></span>getDeleteMatrixHostAtDestroyment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getDeleteMatrixHostAtDestroyment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indica si se destruirá la matriz del host cuando se elimine el objeto. </p>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="a627cb55a45b1a2618387483d24878d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627cb55a45b1a2618387483d24878d63">&#9670;&nbsp;</a></span>getGpuWorkers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classGpuWorker.html">GpuWorker</a>&lt;Toperation&gt;*&gt; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getGpuWorkers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene todos los gpuWorkers de la matriz. </p>
<dl class="section return"><dt>Devuelve</dt><dd>std::vector&lt;GpuWorker&lt;Toperation&gt;*&gt; </dd></dl>

</div>
</div>
<a id="a34fdb08ac465293c535168c626ab181d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fdb08ac465293c535168c626ab181d">&#9670;&nbsp;</a></span>getHostMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Toperation* <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getHostMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el puntero de la matriz global del host. </p>
<dl class="section return"><dt>Devuelve</dt><dd>Toperation* </dd></dl>

</div>
</div>
<a id="ad53a94f43e0c1544a497cb238aaaa364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53a94f43e0c1544a497cb238aaaa364">&#9670;&nbsp;</a></span>getHostMatrixInThisPointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getHostMatrixInThisPointer </td>
          <td>(</td>
          <td class="paramtype">Toperation *&#160;</td>
          <td class="paramname"><em>pointerMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copia la matriz al puntero del host que se pasa como argumento. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointerMatrix,puntero</td><td>donde sera copiada la matriz </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa158ccbaecfba4cbafa36bc424f321e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa158ccbaecfba4cbafa36bc424f321e">&#9670;&nbsp;</a></span>getIsDistributed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getIsDistributed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indica si una matriz esta distribuida o no. </p>
<dl class="section return"><dt>Devuelve</dt><dd>true </dd>
<dd>
false </dd></dl>

</div>
</div>
<a id="a6e00fc3ae8e8c9f0f4acafea1c277896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e00fc3ae8e8c9f0f4acafea1c277896">&#9670;&nbsp;</a></span>getIsMatrixHostHere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getIsMatrixHostHere </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indica si hay una matriz global. </p>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="a1b92a3021af1891db86cf8041cea5b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b92a3021af1891db86cf8041cea5b84">&#9670;&nbsp;</a></span>getMeshColumnSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getMeshColumnSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el tamaño de la malla de las columnas. </p>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="ab7d8f63bf41a6ba3d77dfddda7d891db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d8f63bf41a6ba3d77dfddda7d891db">&#9670;&nbsp;</a></span>getMeshRowSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getMeshRowSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el tamaño de la malla de las filas. </p>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="a0d936d844e9b03ff05979220be754461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d936d844e9b03ff05979220be754461">&#9670;&nbsp;</a></span>getRowsReal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getRowsReal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el valor de filas reales de la verdadera matriz. </p>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="a51fbed871925f5f34b40b0a264b4eff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fbed871925f5f34b40b0a264b4eff6">&#9670;&nbsp;</a></span>getRowsUsed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::getRowsUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtiene el valor de filas que se usará para operar, en caso de no con coincidir con columnsReal significa que el exceso son 0. </p>
<dl class="section return"><dt>Devuelve</dt><dd>int </dd></dl>

</div>
</div>
<a id="ad78ea69222a13a6ef322573b82427787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78ea69222a13a6ef322573b82427787">&#9670;&nbsp;</a></span>norm1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Toperation <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::norm1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcula y devuelve la norma 1 de una matriz. Máxima suma de sus columnas. </p>
<dl class="section return"><dt>Devuelve</dt><dd>Toperation </dd></dl>

</div>
</div>
<a id="a89bb905f0b2d52709331ff0e3ec6733b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bb905f0b2d52709331ff0e3ec6733b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt;&amp; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador * (multiplicación) en caso entre matrices. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">B,La</td><td>otra matriz por la cual se multiplica </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt; </dd></dl>

</div>
</div>
<a id="a2192d54d74edc3e7b2fce277fd2a214f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2192d54d74edc3e7b2fce277fd2a214f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const Toperation &amp;&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador * (multiplicación) en caso de un escalar. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha,escalar</td><td>por el que se multiplicará la matriz </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt; </dd></dl>

</div>
</div>
<a id="a5dcca620fc49b59d8aaf1171b6b0ba6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcca620fc49b59d8aaf1171b6b0ba6f">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt;&amp; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador *= (multiplicación y asignación) en caso entre matrices. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">B,La</td><td>otra matriz por la cual se multiplica </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt; </dd></dl>

</div>
</div>
<a id="ab1a843f990bf1fd8bf644780bac68b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a843f990bf1fd8bf644780bac68b46">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt;&amp; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Toperation &amp;&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador *= (multiplicación y asignación) en caso de un escalar. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha,escalar</td><td>por el que se multiplicará la matriz </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt;&amp; </dd></dl>

</div>
</div>
<a id="a0c1bc3c2ee26975fe979213d9d177608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1bc3c2ee26975fe979213d9d177608">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Toperation &amp;&#160;</td>
          <td class="paramname"><em>constantAddition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador + (suma) de una matriz + la identidad multiplicada por una constante. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">constantAddition,constante</td><td>que multiplicará a la identidad </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt; </dd></dl>

</div>
</div>
<a id="a16c27bc4800c921cc22ad5aa3c159b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c27bc4800c921cc22ad5aa3c159b11">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td>
          <td class="paramname"><em>maMain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador +(suma) de una matriz + otra matriz. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">maMain,matriz</td><td>con la cual se sumará </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt; </dd></dl>

</div>
</div>
<a id="a9c4235d9cb94762af7d7fcf9d3185ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4235d9cb94762af7d7fcf9d3185ae5">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt;&amp; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const Toperation &amp;&#160;</td>
          <td class="paramname"><em>constantAddition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador +=(suma y asignación) de una matriz + la identidad multiplicada por una constante. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">constantAddition,constante</td><td>que multiplicará a la identidad </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt;&amp; </dd></dl>

</div>
</div>
<a id="ac4f89e678cec819cbeffdf363a4bf717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f89e678cec819cbeffdf363a4bf717">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt;&amp; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td>
          <td class="paramname"><em>maMain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador +=(suma y asignación) de una matriz + otra matriz. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">maMain,matriz</td><td>con la cual se sumará </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt;&amp; </dd></dl>

</div>
</div>
<a id="a9105969d693cab31a797b1f5c7e63d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9105969d693cab31a797b1f5c7e63d69">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const Toperation &amp;&#160;</td>
          <td class="paramname"><em>constantSubstraction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador - (resta) de una matriz - la identidad multiplicada por una constante. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">constantSubstraction,constante</td><td>que multiplicará a la identidad </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt; </dd></dl>

</div>
</div>
<a id="ac3ec4e4edf0d77e97cd8b4c8ecfc32ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ec4e4edf0d77e97cd8b4c8ecfc32ee">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td>
          <td class="paramname"><em>maMain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador -(resta) de una matriz - otra matriz. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">maMain,matriz</td><td>con la cual se restará </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt; </dd></dl>

</div>
</div>
<a id="aef5fed2f8190d857c39ed911601910c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5fed2f8190d857c39ed911601910c2">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador del cambio de signo -. Cambia el signo de todos los elementos de una matriz. </p>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt; </dd></dl>

</div>
</div>
<a id="ac5c163a3002d2e8de1e05dcac5ea5df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c163a3002d2e8de1e05dcac5ea5df1">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt;&amp; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const Toperation &amp;&#160;</td>
          <td class="paramname"><em>constantSubstraction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador -= (resta y asignación) de una matriz - la identidad multiplicada por una constante. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">constantSubstraction,constante</td><td>que multiplicará a la identidad </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt; </dd></dl>

</div>
</div>
<a id="a9c12a483991f3b4d90f95e1ca09a4174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c12a483991f3b4d90f95e1ca09a4174">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt;&amp; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td>
          <td class="paramname"><em>maMain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador -=(resta y asignación) de una matriz - otra matriz. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">maMain,matriz</td><td>con la cual se restará </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt;&amp; </dd></dl>

</div>
</div>
<a id="aa18465b7a138010a03901c266f8aa306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18465b7a138010a03901c266f8aa306">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const Toperation &amp;&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador / (división) en caso de un escalar. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha,escalar</td><td>por el que se dividirá la matriz </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt; </dd></dl>

</div>
</div>
<a id="a7533eb0bf566b392286134979c2240f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7533eb0bf566b392286134979c2240f7">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt;&amp; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Toperation &amp;&#160;</td>
          <td class="paramname"><em>alpha</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override del operador *= (dividir y asignación) en caso de un escalar. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha,escalar</td><td>por el que se dividirá la matriz </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt;&amp; </dd></dl>

</div>
</div>
<a id="a7b5bc59c186622de3497b5d70f4ac6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5bc59c186622de3497b5d70f4ac6af">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt;&amp; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override de asignación (=) de <a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a>. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">B,<a class="el" href="classMatrixMain.html" title="Clase que contiene todas las propiedades de una matriz asi como los GpuWorkers asociados a ella...">MatrixMain</a></td><td>que contiene los valores a asignar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt;&amp; </dd></dl>

</div>
</div>
<a id="a04803e3d88409e75bf45dfde76b640b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04803e3d88409e75bf45dfde76b640b5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;Toperation&gt;&amp; <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asignación de movimiento. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;Toperation&gt;&amp; </dd></dl>

</div>
</div>
<a id="ac7b3657c7ce39feb11815971d2ec1382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b3657c7ce39feb11815971d2ec1382">&#9670;&nbsp;</a></span>recoverMatrixToHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::recoverMatrixToHost </td>
          <td>(</td>
          <td class="paramtype">Toperation *&#160;</td>
          <td class="paramname"><em>pointerMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve la matriz de las gpus al host en el puntero indicado. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointerMatrix,puntero</td><td>que contendrá la matriz </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e67efda03cdd8e70215247b7f857002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e67efda03cdd8e70215247b7f857002">&#9670;&nbsp;</a></span>setAlphaGemm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::setAlphaGemm </td>
          <td>(</td>
          <td class="paramtype">Toperation&#160;</td>
          <td class="paramname"><em>alphaGemm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asigna el valor del escalar alfa para la operacion GEMM. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">alphaGemm</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa85480f53c9b1deea09d5fbed1a48d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85480f53c9b1deea09d5fbed1a48d2e">&#9670;&nbsp;</a></span>setColumnsUsed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::setColumnsUsed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>columnsUsed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asigna el valor de columnas que se usará para operar, en caso de no con coincidir con columnsReal significa que el exceso son 0. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">columnsUsed</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c8cf3be535a8bb042f6ee0ddaafc6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8cf3be535a8bb042f6ee0ddaafc6b1">&#9670;&nbsp;</a></span>setDeleteMatrixHostAtDestroyment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::setDeleteMatrixHostAtDestroyment </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteMatrixHostAtDestroyment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asigna si se destruirá la matriz del host cuando se destruya el objeto. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">deleteMatrixHostAtDestroyment</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c00132316f5c4c39259281d8e9d3e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c00132316f5c4c39259281d8e9d3e95">&#9670;&nbsp;</a></span>setIsDistributed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::setIsDistributed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isDistributed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asigna si una matriz está distribuida o no. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">isDistributed</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6efed0175fedf515e3356ea3c27d3d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6efed0175fedf515e3356ea3c27d3d5a">&#9670;&nbsp;</a></span>setIsMatrixHostHere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::setIsMatrixHostHere </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMatrixHostHere</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asigna si hay una matriz en el host. En caso de que se asigne que no y este la matriz, se liberan recursos y se asigna nullptr. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">isMatrixHostHere</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cbc27697a76770978dde0e4b0edc732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbc27697a76770978dde0e4b0edc732">&#9670;&nbsp;</a></span>setMatrixHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::setMatrixHost </td>
          <td>(</td>
          <td class="paramtype">Toperation *&#160;</td>
          <td class="paramname"><em>newMatrixHost</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asigna una nueva matriz a matrixHost y destruye los gpuWorkers que existían antes y la matrixHost que hubiese antes. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">newMatrixHost</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6fa4a668ce7857289dc0931b319429e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fa4a668ce7857289dc0931b319429e">&#9670;&nbsp;</a></span>setMatrixHostToFullValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::setMatrixHostToFullValue </td>
          <td>(</td>
          <td class="paramtype">Toperation&#160;</td>
          <td class="paramname"><em>valueForHost</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asigna un valor a todos los elementos de la matriz de matrixHost. Elimina la que había con anterioridad. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">valueForHost,valor</td><td>de todos los elementos de la matriz </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a955eceba34f3a4b617a6fab1a97159cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955eceba34f3a4b617a6fab1a97159cd">&#9670;&nbsp;</a></span>setMatrixOperationProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::setMatrixOperationProperties </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshRowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshColumnSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockRowSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blockColumnSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asigna las propiedades de la matriz para la operacion que se va a realizar. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshRowSize,tamaño</td><td>de la malla en número de filas </td></tr>
    <tr><td class="paramname">meshColumnSize,tamaño</td><td>de la malla en número de columnas </td></tr>
    <tr><td class="paramname">blockRowSize,tamaño</td><td>de las filas en un bloque </td></tr>
    <tr><td class="paramname">blockColumnSize,tamaño</td><td>de las columnas en un bloque </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed24dfbeb31237e66b29e13a66ce2ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed24dfbeb31237e66b29e13a66ce2ef2">&#9670;&nbsp;</a></span>setRowsUsed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; Toperation &gt;::setRowsUsed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowsUsed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asigna el valor de filas que se usará para operar, en caso de no con coincidir con columnsReal significa que el exceso son 0. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowsUsed</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Documentación de las funciones relacionadas y clases amigas</h2>
<a id="addc3df8f6d3a91a9e8e23005d0a099e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc3df8f6d3a91a9e8e23005d0a099e2">&#9670;&nbsp;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
<div class="memtemplate">
template&lt;typename To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;To&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; To &gt; &amp;&#160;</td>
          <td class="paramname"><em>maMain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override del operador * (multiplicación) en caso de un escalar. Escalar * matriz. </p>
<dl class="tparams"><dt>Parámetros del template</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To,tipo</td><td>de la matriz </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha,escalar</td><td>por el que se dividirá la matriz </td></tr>
    <tr><td class="paramname">maMain,matriz</td><td>que se va a multiplicar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;To&gt; </dd></dl>

</div>
</div>
<a id="a83759ded6e3b7e9182b65f7ad77853a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83759ded6e3b7e9182b65f7ad77853a8">&#9670;&nbsp;</a></span>operator+</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
<div class="memtemplate">
template&lt;typename To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;To&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>constantAddition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; To &gt; &amp;&#160;</td>
          <td class="paramname"><em>maMain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override del operador + (suma) de la identidad multiplicada por un número y otra matriz. </p>
<dl class="tparams"><dt>Parámetros del template</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To,tipo</td><td>de la matriz </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">constantAddition,constante</td><td>que multiplicará a la identidad </td></tr>
    <tr><td class="paramname">maMain,matriz</td><td>a sumar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;To&gt; </dd></dl>

</div>
</div>
<a id="a01ae6469adf07f6a6b0f220beab3ed1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ae6469adf07f6a6b0f220beab3ed1d">&#9670;&nbsp;</a></span>operator-</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Toperation &gt; </div>
<div class="memtemplate">
template&lt;typename To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrixMain.html">MatrixMain</a>&lt;To&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>constantSubstraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMatrixMain.html">MatrixMain</a>&lt; To &gt; &amp;&#160;</td>
          <td class="paramname"><em>maMain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override del operador + (suma) de la identidad multiplicada por un número y otra matriz. </p>
<dl class="tparams"><dt>Parámetros del template</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To,tipo</td><td>de la matriz </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">constantSubstraction,constante</td><td>que multiplicará a la identidad </td></tr>
    <tr><td class="paramname">maMain,matriz</td><td>que va a ser restada </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>MatrixMain&lt;To&gt; </dd></dl>

</div>
</div>
<hr/>La documentación para esta clase fue generada a partir de los siguientes ficheros:<ul>
<li>include/cuda/GpuWorker.cuh</li>
<li>include/cuda/MatrixMain.cuh</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
